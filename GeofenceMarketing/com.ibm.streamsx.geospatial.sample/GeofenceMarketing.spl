
/* Copyright (C) 2015, International Business Machines Corporation  */
/* All Rights Reserved    
 * 
 */
namespace com.ibm.streamsx.geospatial.sample ;

use com.ibm.streams.geospatial::* ;
use com.ibm.streams.geospatial.ext::* ;
use com.ibm.streams.geospatial::Geofence ;
use com.ibm.streamsx.messaging.kafka::KafkaProducer ;
use com.ibm.streamsx.messaging.kafka::KafkaConsumer ;

/**This application demonstrates the basic use of the GeoFence operator.
 * There are two data sources to this application:
 * * Randomized entities stream that simulates GPS data from cell phones
 * * A directory scan that watches the GeofenceMarketing/fences directory.  Initially, the directory contains csv file that contains geospatial data of shopping mall near Toronto.
 *   The DirectoryScan allows us to update geofences in the Geofence operator dynamically at runtime, wihtout having to restart the application. 
 * 
 * As data flows, the Geofence operator is set up to detect fenceEntry and fenceExit events.  When we detect an entity has entered a fenced area, the applicaiton
 * looks for marketing promotions from that area and sends the promotion info to the cell phone user.
 * 
 * To see this applicaiton in action, after you have launched the application, go to the following page in a browser:
 * http://<PE Host of MapViewer Operator>:8080/map/map.html?popup=true
 * 
 * */
composite GeofenceMarketingMain
{
	type
		Point = rstring id, rstring wkt ;
		FenceData = rstring fenceId, int32 fenceUpdateAction, rstring fencePolygon ;
		MatchedFences = tuple<list<rstring> fences, list<rstring> fencesEntered,
			list<rstring> fencesExited> ;
		Profile = rstring id, rstring age, rstring gender, rstring interest ;
		Offer = rstring offer ;
	graph
		stream<FenceData> PolygonStream = FileSource(FenceDir)
		{
			param
				format : csv ;
		}

		stream<Point, MatchedFences> GeofenceEvents = Geofence(KafkaConsumer_9_out0
			as inPort0Alias ; PolygonStream)
		{
			param
				outputMode : events ;
				geometry : wkt ;
			output
				GeofenceEvents : fences = CurrentFences(), fencesEntered = FencesEntered(),
					fencesExited = FencesExited() ;
		}

		stream<MapViewerT> EntitiesWithPromotion = Functor(Join_13_out0 as
			inPort0Alias)
		{
			logic
				state :
				{
					mutable rstring promotions = "" ;
				}

				onTuple inPort0Alias :
				{
					promotions = "" ;
					// if the entity has entered a geofence
					if(size(inPort0Alias.fencesEntered) > 0)
					{
					// for each geofence, find promotion and display on map
						for(int32 i in range(inPort0Alias.fencesEntered))
						{
							rstring location = inPort0Alias.fencesEntered [ i ] ;
							promotions += location + ": " ;
							promotions += offer ;
							promotions += "\n" ;
						}

					}

				}

			output
				EntitiesWithPromotion : updateAction = 1u, note = promotions, markerType =
					GREEN ;
		}

		/** MapViewer makes use of the HTTPTupleView operator to allow us to visualize the data		
		in a browser.		
		*/
		() as MapViewer_7 = MapViewer(EntitiesWithPromotion, PolygonToMapViewer)
		{
		}

		(stream<MapViewerT> PolygonToMapViewer) = Custom(PolygonStream)
		{
			logic
				onTuple PolygonStream :
				{
					MapViewerT fencePt = { id = PolygonStream.fenceId, updateAction =(uint32)
						fenceUpdateAction, note = "FencePt", wkt = PolygonStream.fencePolygon,
						markerType = RED } ;
					submit(fencePt, PolygonToMapViewer) ;
				}

		}

		(stream<rstring filename> FenceDir) as FenceDirScan = DirectoryScan()
		{
			param
				directory : dataDirectory() + "/fences" ;
				initDelay : 3.0 ;
		}

		(stream<rstring id, rstring wkt> KafkaConsumer_9_out0) as KafkaConsumer_9 =
			KafkaConsumer()
		{
			param
				topic : "geofenceMarketingGPS" ;
				keyAttribute : "id" ;
				messageAttribute : "wkt" ;
				propertiesFile : "etc/consumer.properties" ;
		}

		() as CustomerGPSGenerator = GpsFromCustomerGenerator()
		{
		}

		(stream<rstring id, rstring age, rstring gender, rstring interest>
			FileSource_9_out0) as FileSource_9 = FileSource()
		{
			param
				file : "profiles.dat" ;
				format : csv ;
				//deleteFile : true;
				//initDelay : 2.0;
				hotFile : true ;
		}

		stream<Point, MatchedFences, Profile> Join_10 = Join(GeofenceEvents as L ;
			FileSource_9_out0 as R)
		{
			window
				L : sliding, count(1u) ;
				R : sliding, count(999u) ; //we don't actually want this to empty

			param
				equalityLHS : L.id ;
				equalityRHS : R.id ;
			output
				Join_10 : id = L.id ; //, age = R.age, gender = R.gender
				//, interest = R.interest ;

		}

		() as Custom_11 = FileSink(Join_10)
		{
			param
				file : "outOfJoin.dat" ;
				format : csv ;
				flush : 1u ;
		}

		() as Custom_12 = FileSink(Join_13_out0 as InputStreamName0)
		{
			param
				file : "outOfJoin2.dat" ;
				format : csv ;
				flush : 1u ;
		}

		(stream<rstring interest, rstring offer> FileSource_12_out0) as
			FileSource_12 = FileSource()
		{
			param
				file : "offers.dat" ;
				format : csv ;
		}

		stream<Offer, Point, MatchedFences, Profile> Join_13_out0 = Join(Join_10 as
			L ; FileSource_12_out0 as R)
		{
			window
				L : sliding, count(1u) ;
				R : sliding, count(999u) ;
			param
				equalityLHS : L.interest ;
				equalityRHS : R.interest ;
			output
				Join_13_out0 : interest = L.interest ;
		}

}
